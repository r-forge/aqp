<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Determine ML Horizon Boundaries</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/languages/r.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</head><body>

<table width="100%" summary="page for get.ml.hz {aqp}"><tr><td>get.ml.hz {aqp}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Determine ML Horizon Boundaries</h2>

<h3>Description</h3>

<p>This function accepts input from <code>slab()</code> along with a vector of horizon names, and returns a <code>data.frame</code> of the most likely horizon boundaries.</p>


<h3>Usage</h3>

<pre>
get.ml.hz(x, o.names)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>output from <code><a href="SPC-slab-methods.html">slab</a></code></p>
</td></tr>
<tr valign="top"><td><code>o.names</code></td>
<td>
<p>an optional character vector of horizon designations that will be used in the final table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is expecting that <code>x</code> is a data.frame generated by <code><a href="SPC-slab-methods.html">slab</a></code>. If <code>x</code> was not generated by <code>slab</code>, then <code>o.names</code> is required.</p>


<h3>Value</h3>

<p>A dataframe with the following columns:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>hz</code></td>
<td>
<p>horizon names</p>
</td></tr>
<tr valign="top"><td><code>top</code></td>
<td>
<p>top boundary</p>
</td></tr>
<tr valign="top"><td><code>bottom</code></td>
<td>
<p>bottom boundary</p>
</td></tr>
<tr valign="top"><td><code>confidence</code></td>
<td>
<p>integrated probability / ML horizon thickness, rounded to the nearest integer</p>
</td></tr>
<tr valign="top"><td><code>pseudo.brier</code></td>
<td>
<p>A &quot;pseudo&quot;&quot; Brier Score for a multi-class prediction, where the most-likely horizon label is treated as the &quot;correct&quot; outcome. Details on the calculation for traditional Brier Scores here: <a href="http://en.wikipedia.org/wiki/Brier_score#Original_definition_by_Brier">http://en.wikipedia.org/wiki/Brier_score#Original_definition_by_Brier</a>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>D.E. Beaudette</p>


<h3>See Also</h3>

<p><code><a href="SPC-slab-methods.html">slab</a></code></p>


<h3>Examples</h3>

<pre><code class="r">data(sp1)
depths(sp1) &lt;- id ~ top + bottom

# normalize horizon names: result is a factor
sp1$name &lt;- generalize.hz(sp1$name, 
  new=c(&#39;O&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;), 
  pat=c(&#39;O&#39;, &#39;^A&#39;,&#39;^B&#39;,&#39;C&#39;))

# compute slice-wise probability so that it sums to contributing fraction, from 0-150
a &lt;- slab(sp1, fm= ~ name, cpm=1, slab.structure=0:150)

# generate table of ML horizonation
get.ml.hz(a, o.names=c(&#39;O&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;))
</code></pre>

<pre><code>##   hz top bottom confidence pseudo.brier
## 1  O   0      2         37    0.3950617
## 2  A   2     32         75    0.1547325
## 3  B  32    145         57    0.3574667
## 4  C 145    150         71    0.1250000
</code></pre>


<hr /><div style="text-align: center;">[Package <em>aqp</em> version 1.9.1 <a href="00Index.html">Index</a>]</div>
</body></html>
