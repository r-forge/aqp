<!DOCTYPE html>
<head>
  <title>Soil Database Interface: the soilDB package</title>
</head>
<h1>Soil Database Interface: the <tt>soilDB</tt> package</h1>

<body>
<!--begin.rcode echo=FALSE
  opts_chunk$set(message=FALSE, warning=FALSE, background='#F7F7F7', dpi=100, fig.align='center', dev='CairoPNG')
  end.rcode-->

<!--begin.rcode setup, echo=FALSE, results='hide'
options(replace.assign=TRUE, width=140, stringsAsFactors=FALSE)
end.rcode-->


<h2>Introduction</h2>
This package provides methods for extracting soils information from local PedonPC and AK Site databases (MS Access format), local NASIS databases (MS SQL Server), and the SDA webservice. Currently USDA-NCSS data sources are supported, however, there are plans to develop interfaces to outside systems such as the Global Soil Mapping project.

It can be difficult to locate all of the dependencies required for sending/processing SOAP requests, especially on UNIX-like operating systems. Windows binary packages for the dependencies can be found <a href="http://www.stats.ox.ac.uk/pub/RWin/bin/windows/contrib/2.14/">here</a>.

This document is based on <tt>aqp</tt> version <!--rinline utils::packageDescription("aqp", field="Version")--> and <tt>soilDB</tt> version <!--rinline utils::packageDescription("soilDB", field="Version")-->.


<h3>Inteded Users</h3>


</h3>R Notes</h3>
A basic understanding of R syntax, object structure, package management system, and programming style will greatly help with integration of the <tt>soilDB and aqp</tt> packages into standard workflows. Here are some reminders. Recall that online help documents can be accessed with the syntax `?mean', which would load the manual page for the `mean()' function. Two `??' can be used to perform fuzzy searching for functions that contain matching keywords.


<!--begin.rcode R-notes, eval=FALSE
# 1. objects: creation, structure, etc.
x <- 1:10       # 'x' is now a vector of integers 1 to 10 
y <- rnorm(10)  # 'y' is now a vector of 10 random numbers {mean=0, sd=1}
d <- data.frame(x, y) # d is a rectangular table with columns 'x' and 'y'

str(d) # check structure
class(d) # inspect object class
head(d) # view first 6 rows
rm(d, x, y) # clean-up by deleting these objects

# 2. most function are vectorized: i.e. automatic iteration
x <- 1:10
x + 1 # the '+' function knows about vectors, and recycles scalars accordingly

# 3. missing data can cause problems unless accounted for
x <- c(x, NA) # 'c()' is the concatonate function
x
mean(x) # result is NA, as most functions return NA in the presence of missing data
mean(x, na.rm=TRUE) # mean computed after removal of missing data
end.rcode-->


<h3>Design</h3>

The <tt>soilDB</tt> package provides two layers of functionality for extracting data from file-based databases (PedonPC), relational databases (local NASIS), and online data sources (Soil Data Access). High-level functions <tt>fetchPedonPC()</tt> and <tt>fetchNASIS()<tt> query, combine, verify horizon logic, and return <tt>SoilProfileCollection</tt> class objects containing the most commonly used site/pedon/horizon data. Low-level functions such as <tt>get_site_data_from_pedon_db()</tt> and <tt>get_hz_data_from_pedon_db()</tt> extract specific data from a designated source, and return the results as a <tt>data.frame</tt> class object.

<h3>High-Level Functions</h3>

<h3>Low-Level Functions</h3>

<!--begin.rcode pedonPC-demo, eval=FALSE
library(soilDB)
# this will only work if you have a PedonPC Database and Windows :(
# get all of the data (you will have to adjust the DSN)
dsn <- "S:/Service_Center/NRCS/pedon/pedon.mdb"
s <- fetchPedonPC(dsn)

# subset 'Gopheridge' pedons
subset.idx <- grep('gopheridge', gopheridge$correlated_as, ignore.case=TRUE)
gopheridge <- s[subset.idx, ]
end.rcode-->


<h2>Examples</h2>


<!--begin.rcode gopheridge-demo, eval=TRUE
# libraries: you may have to install these
library(soilDB)
library(Hmisc)
library(ape)
library(lattice)
library(cluster)
library(reshape)

# load example dataset
data(gopheridge)

## aggregates of horizon data, moved into @site

# soil depth using an in-line function, note that max(SPC) returns the bottom-most depth
# this may not be the same as 'soil depth' when Cr or R horizons are present
gopheridge$soil.depth <- profileApply(gopheridge, function(x) max(x))

# horizon-thickness weighted mean (beware of NA)
f.wt.prop <- function(x, prop) {h <- horizons(x); w <- with(h, hzdepb-hzdept); wtd.mean(h[[prop]], weights=w)}

# get hz mid-point of hz with max clay content
f.max.clay.depth <- function(x) {
	h <- horizons(x) 
	max.clay <- which.max(h$clay) 
	with(h[max.clay, ], (hzdept+hzdepb) / 2)
	}

# apply by-profile, returning a vector, assigned to new column in @site
gopheridge$wt.clay <- profileApply(gopheridge, f.wt.prop, prop='clay')
gopheridge$wt.rf <- profileApply(gopheridge, f.wt.prop, prop='total_frags_pct')
gopheridge$max.clay.depth <- profileApply(gopheridge, f.max.clay.depth)


# compute aggregate (wt.mean) clay within particle-size control section
# note that this requires conditional eval of data that may contain NA
# see ?slab and ?soil.slot for details on the syntax
f.pcs.prop <- function(x, prop) {
  # these are accessed from @site
  sv <- c(x$psctopdepth, x$pscbotdepth)
  # test for missing PCS data
  if(any(is.na(sv)))
    return(NA)

  # create formula from named property
  fm <- as.formula(paste('~', prop))
  # return just the (weighted) mean, accessed from @horizons
  s <- slab(x, fm, seg_vect=sv)$p.mean
  return(s)
}


# compute the weighted-mean of some property within a given diagnostic horizon
# note that this requires conditional eval of data that may contain NA
# see ?slab and ?soil.slot for details on the syntax
# note that function expects certain columns within 'x'
f.diag.wt.prop <- function(x, d.hz, prop) {
	# extract diagnostic horizon data
	d <- diagnostic_hz(x)
	# subset to the requested diagnostic hz
	d <- d[d$diag_kind == d.hz, ]
	# if missing return NA
	if(nrow(d) == 0)
		return(NA)
	
	# extract depths and check for missing
	sv <- c(d$featdept, d$featdepb)
	if(any(is.na(sv)))
		return(NA)
	
	# create formula from named property
	fm <- as.formula(paste('~', prop))
	# return just the (weighted) mean, accessed from @horizons
	s <- slab(x, fm, seg_vect=sv)$p.mean
	return(s)
}


# conditional eval of thickness of some diagnostic feature or horizon
# will return a vector of length(x), you can save to @site
f.diag.thickness <- function(x, d.hz) {
	# extract diagnostic horizon data
	d <- diagnostic_hz(x)
	# subset to the requested diagnostic hz
	d <- d[d$diag_kind == d.hz, ]
	# if missing return NA
	if(nrow(d) == 0)
		return(NA)
	
	# compute thickness
	thick <- d$featdepb - d$featdept
	return(thick)
}

# conditional eval of top hz depth of diagnostic feature or horizon
# will return a vector of length(x), you can save to @site
f.diag.top <- function(x, d.hz) {
	# extract diagnostic horizon data
	d <- diagnostic_hz(x)
	# subset to the requested diagnostic hz
	d <- d[d$diag_kind == d.hz, ]
	# if missing return NA
	if(nrow(d) == 0)
		return(NA)
	
	# return top depth
	return(d$featdept)
}


# compute wt.mean clay within PCS, save to @site
gopheridge$pcs.clay <- profileApply(gopheridge, f.pcs.prop, prop='clay')

# compute wt.mean clay within argillic horizon, save to @site
gopheridge$argillic.clay <- profileApply(gopheridge, f.diag.wt.prop, d.hz='argillic horizon', prop='clay')

# compute argillic hz thickness, save to @site
gopheridge$argillic.thick <- profileApply(gopheridge, f.diag.thickness, d.hz='argillic horizon')

# compute depth to paralithic contact, if present, save to @site
gopheridge$paralithic.contact.depth <- profileApply(gopheridge, f.diag.top, d.hz='paralithic contact')
end.rcode-->




<!--begin.rcode basic_plotting, fig.width=15, fig.height=5, out.width='100%'
# order by presence of paralithic contact
new.order <- order(gopheridge$paralithic.contact)
plot(gopheridge, name='hzname', plot.order=new.order)
# annotate paralithic contact with lines
x.pos <- 1:length(gopheridge)
lines(x.pos, gopheridge$paralithic.contact.depth[new.order], lty=2, col='black')
end.rcode-->


</body>
</html>
