<!--
manually process like this:
library(knitr); library(markdown)
knit('aqp-intro.Rmd')
markdownToHTML('aqp-intro.md', 'aqp-intro.html')
-->

```{r setup, echo=FALSE, results='hide'}
opts_chunk$set(message=FALSE, warning=FALSE, background='#F7F7F7', dpi=100, fig.align='center', dev='CairoPNG', tidy=FALSE)
options(width=100, stringsAsFactors=FALSE)
```

## Introduction to SoilProfileCollection Objects
This is a very basic introduction to the `SoilProfileCollection` class object defined in the `aqp` package for **R**. The `SoilProfileCollection` class was designed to simplifiy the process of working with the collection of data associated with soil profiles: site-level data, horizon-level data, spatial data, diagnostic horizon data, metadata, etc. Examples listed below are meant to be copied/pasted from this document and interactively run within **R**. Comments (green text) briefly describe what the code in each line does. This document assumes a basic level of proficiency with **R** which can be gained by reviewing some of the material in [tutorials like this](http://cran.r-project.org/doc/contrib/Verzani-SimpleR.pdf).


### Object Creation
`SoilProfileCollection` are typically created by "promoting" `data.frame` objects (rectangular tables of data) that contain at least three essential columns: 1) an ID column uniquely identifying groups of horizons, 2) horizon top boundaries, and, 3) horizon bottom boundaries. Ideally the `data.frame` is pre-sorted according to the profile ID and horizon top boundary. Formula notation is used to define these columns using the pattern: 

```{r promote_to_spc, eval=FALSE} 
idcolumn ~ hz_top_column + hz_bottom_column
```

In this tutorial we will use some sample data included with the `aqp` package, based on characterization data from 10 soils sampled on serpentinitic parent material as described in [McGahan et al, 2009](https://www.soils.org/publications/sssaj/articles/73/6/2087). The [scales](http://cran.at.r-project.org/web/packages/scales/index.html) and [RColorBrewer](http://cran.at.r-project.org/web/packages/RColorBrewer/index.html) packages are used to translate soil properties into colors.
```{r creation}
# load required packages, you may have to install these if missing:
# install.packages('aqp', dep=TRUE)
# install.packages('scales', dep=TRUE)
# install.packages('RColorBrewer', dep=TRUE)
library(aqp)
library(scales)
library(RColorBrewer)

# load sample data set, a simple data.frame object with horizon-level data from 10 profiles
data(sp4)
str(sp4)

# optionally read about it...
# ?sp4

# upgrade to SoilProfileCollection
# 'id' is the name of the column containing the profile ID
# 'top' is the name of the column containing horizon upper boundaries
# 'bottom' is the name of the column containing horizon lower boundaries
depths(sp4) <- id ~ top + bottom

# check it out:
class(sp4) # class name
print(sp4)
```


### Accessing, Setting, and Replacing Components of a `SoilProfileCollection`
"Accessor" functions are used to extract specfic components from within `SoilProfileCollection` objects.
```{r accessor-functions, eval=FALSE}
# methods for object inspection
idname(sp4) # self-explanitory
horizonDepths(sp4) # self-explanitory
depth_units(sp4) # defaults to 'cm'
metadata(sp4) # not much to start with
profile_id(sp4) # vector of profile IDs

# further inspection with common function overloads
length(sp4) # number of profiles in the collection
nrow(sp4) # number of horizons in the collection
names(sp4) # column names from site and horizon data
min(sp4) # shallowest profile depth in collection
max(sp4) # deepest profile depth in collection
```


Several accessor functions can also be used to define, modify, or replace components within `SoilProfileCollection` objects. For example, 
```{r get-example, eval=FALSE}
horizons(sp4)
``` 
will extract horizon data and 

```{r set-example, eval=FALSE}
horizons(sp4) <- x` 
```

will replace horizon data. Further examples include:
```{r setter-functions, eval=FALSE}
# extraction of soil profile components
horizons(sp4) # get or set horizon data
site(sp4)  # get or set site data
diagnostic_hz(sp4) # get or set diagnostic horizons
```


### Horizon and Site Data
```{r hz_and_site_data}
# extract horizon data to data.frame
h <- horizons(sp4)

# add a new column and save back to original object
h$random.numbers <- rnorm(n=nrow(h), mean=0, sd=1)

# _replace_ original horizon data with modified version
# ! row-order should not be altered !
horizons(sp4) <- h

# extract site data to data.frame
s <- site(sp4)

# add a fake group to the site data
s$group <- rep(c('A', 'B'), length.out=nrow(s))

# merge-in new site data, old data are _not_ replaced
site(sp4) <- s

# extraction of specific attributes by name
sp4$clay # vector of clay content (horizon data)
sp4$group # vector of group membership (site data)

# assignment of new data to existing or new attributes
sp4$elevation <- rnorm(n=length(sp4), mean=1000, sd=150) # site-level, based on length of assigned data
sp4$thickness <- sp4$bottom - sp4$top # horizon-level

# assign a single single value into horizon-level attributes
sp4$constant <- rep(1, times=nrow(sp4))

# promote horizon-level data to site-level data (when it makes sense to do so)
# note that this _moves_ the named column from horizon to site
site(sp4) <- ~ constant 
```


### Diagnostic Horizons
```{r diagnostic}
# manually create some diagnostic horizon data
# there is no restrictions on data format, as long as each row has an ID that exists within the collection
# be sure to use the ID column name that was used to initialize the SoilProfileCollection object
# check via: idname(sp4)
dh <- data.frame(id='colusa', kind='argillic', top=8, bottom=42, stringsAsFactors=FALSE)

# overwrite any existing diagnostic horizon data
diagnostic_hz(sp4) <- dh

# append to diagnostic horizon data
dh <- diagnostic_hz(sp4)
dh.new <- data.frame(id='napa', kind='argillic', top=6, bottom=20, stringsAsFactors=FALSE)

# overwrite existing diagnostic horizon data with appended data
diagnostic_hz(sp4) <- rbind(dh, dh.new)
```


### Spatial Data
Spatial data can be explicitly stored within a `SoilProfileCollection` object and accessed with methods imported from the [sp](http://cran.at.r-project.org/web/packages/sp/index.html) package. The use of `sp` objects (in this case `SpatialPoints` and `SpatialPoints`) simplifies operations such as [plotting spatial data, coordinate system transformations, and spatial queries](http://cran.at.r-project.org/web/packages/sp/vignettes/intro_sp.pdf).
```{r spatial, fig.width=4, fig.height=4}
# generate some fake coordinates as site level attributes
sp4$x <- rnorm(n=length(sp4), mean=354000, sd=100)
sp4$y <- rnorm(n=length(sp4), mean=4109533, sd=100)

# initialize spatial coordinates
coordinates(sp4) <- ~ x + y

# extract coordinates as matrix
coordinates(sp4)

# get/set spatial reference system using PROJ4 syntax
proj4string(sp4) <- '+proj=utm +zone=11 +datum=NAD83'
proj4string(sp4)

# extract spatial data + site level attribtutes
# see ?SpatialPointsDataFrame for details
sp4.sp <- as(sp4, 'SpatialPointsDataFrame')

# plot the results
plot(sp4.sp)
box()
```


### Subsetting SoilProfileCollection Objects
```{r subsetting}
# matrix-style subsetting
sp4[1:2, ] # profiles 1--2 from the collection
sp4[, 1:2] # horizons 1--2 from each profile

# in the presence of spatial data, subsetting can either result in 
# 1. a new SoilProfileCollection (> 1 horizon / profile)
# 2. a new SpatialPointsDataFrame (1 horizon / profile)
class(sp4[1, ]) # profile 1 from the collection
class(sp4[, 1]) # horizon 1 from each profile

# filtering criteria from horizon and site level data
subsetProfiles(sp4, h='clay < 20', s='group == "A"')
```


### Plotting SoilProfileCollection Objects
```{r plotting, fig.height=4, fig.width=8}
# basic plot method, highly customizable: see manual page ?plotSPC
plot(sp4)

# inspect plotting area, very simple to overlay graphical elements
abline(v=1:length(sp4), lty=3, col='blue')

# profiles are centered at integers, from 1 to length(obj)
axis(1, line=-1.5, at=1:10, cex.axis=0.75, font=4, col='blue', lwd=2)

# y-axis is based on profile depths
axis(2, line=-1, at=pretty(1:max(sp4)), cex.axis=0.75, font=4, las=1, col='blue', lwd=2)

# setup some colors to symbolize soil properties
cols <- rev(brewer.pal(8, 'Spectral'))

# generate a color ramp function based on the color pallette defined above
cr <- colorRamp(cols)

# associate colors with exchangeable Ca:Mg, and save to new horizon-level attribute
sp4$soil_color <- rgb(cr(rescale(sp4$ex_Ca_to_Mg)), max=255)

# plot again, this time using new colors
plot(sp4) # how does it know about horizon names / colors? see the manual page.
```


### Iterating Over Profiles in a Collection
```{r util-functions, fig.height=4, fig.width=8}
# apply a function to each profile, returning a single value per profile,
# in the same order as profile_id(sp4)
soil.depths <- profileApply(sp4, max) # recall that max() gives the depth of a soil profile

# check that the order is correct
print(soil.depths)
all.equal(names(soil.depths), profile_id(sp4))

# compute the max Ca/Mg value per profile and save as a site-level attribute
sp4$max_ca_to_mg <- profileApply(sp4, function(i) max(i$ex_Ca_to_Mg, na.rm=TRUE))

# use site-level data to alter plotting order
new.order <- order(sp4$max_ca_to_mg) # the result is an index of rank
plot(sp4, plot.order=new.order)
# add an axis labeled with the sorting criteria
axis(1, at=1:length(sp4), labels=sp4$max_ca_to_mg)
```


### Slicing and Aggregating Objects
```{r slice_slab, fig.height=4, fig.width=8}
# slice from 0--15 cm in 1-cm intervals
# formula notation is used to selection which variables are included
# the result is a new SoilProfileCollection object, site data are retained
sliced <- slice(sp4, fm= 0:15 ~ sand + silt + clay + name + soil_color)
plot(sliced)

# see ?slice for details

# aggregate a couple of the horizon-level attributes, 
# across the entire collection, 
# from 0--10 cm
# computing the mean value ignoring missing data
slab(sp4, fm= ~ sand + silt + clay, slab.structure=c(0,10), slab.fun=mean, na.rm=TRUE)

# again, this time over several depth ranges
slab(sp4, fm= ~ sand + silt + clay, slab.structure=c(0,10,25,40), slab.fun=mean, na.rm=TRUE)

# again, this time along 1-cm slices, computing quantiles
agg <- slab(sp4, fm= ~ sand + silt + clay)

# see ?slab for details on the default aggregate function
head(agg)

# plot median +/i bounds defined by the 25th and 75th percentiles
# this is lattice graphics, syntax is a little rough
library(lattice)
xyplot(top ~ p.q50 | variable, data=agg, ylab='Depth',
			 xlab='median bounded by 25th and 75th percentiles',
			 lower=agg$p.q25, upper=agg$p.q75, ylim=c(50,-5), alpha=0.5, 
			 panel=panel.depth_function, 
			 prepanel=prepanel.depth_function,
			 cf=agg$contributing_fraction,
			 layout=c(3,1), scales=list(x=list(alternating=1))
			 )
```


### Object Metadata
```{r metadata, eval=FALSE}
# print metadata:
metadata(sp4)

# alter the depth unit metadata attribute
depth_units(sp4) <- 'inches' # units are really 'cm'

# more generic interface for adjusting metadata
md <- metadata(sp4) # save original metadata

# add columns
md$describer <- 'DGM'
md$date <- as.Date('2009-01-01')
md$citation <- 'McGahan, D.G., Southard, R.J, Claassen, V.P. 2009. Plant-Available Calcium Varies Widely in Soils on Serpentinite Landscapes. Soil Sci. Soc. Am. J. 73: 2087-2095.'

# re-assign user defined metadata to original object
metadata(sp4) <- md

# check:
metadata(sp4)

# fix depth units, set back to 'cm'
depth_units(sp4) <- 'cm'
```


### Object Structure and Coercion
```{r coercion, eval=FALSE}
# check our work by viewing the internal structure
str(sp4)

# deconstruct SoilProfileCollection into a data.frame, with horizon+site data
as(sp4, 'data.frame')

# extraction of site + spatial data as SpatialPointsDataFrame
as(sp4, 'SpatialPointsDataFrame')
```
